Metadata-Version: 2.1
Name: truths
Version: 1.2
Summary: auto generate truth tables
Home-page: https://github.com/tr3buchet/truths
Author: Trey Morris
Author-email: trey@treymorris.com
License: Apache Software License
Keywords: truth,table,truth table,truthtable,logic
Classifier: Development Status :: 5 - Production/Stable
Classifier: License :: OSI Approved :: Apache Software License
License-File: LICENSE

truths - auto generate truth tables
===================================

truths is a simple tool that allows you to quickly generate a truth
table from python variable names and phrases

install
-------

``pip install truths`` or ``git clone`` and ``pip install -e`` to play
with the code

use is simple:
~~~~~~~~~~~~~~

start by creating some base variables

.. code:: python

    import truths
    print truths.Truths(['a', 'b', 'x'])

::

    +---+---+---+
    | a | b | x |
    +---+---+---+
    | 0 | 0 | 0 |
    | 0 | 0 | 1 |
    | 0 | 1 | 0 |
    | 0 | 1 | 1 |
    | 1 | 0 | 0 |
    | 1 | 0 | 1 |
    | 1 | 1 | 0 |
    | 1 | 1 | 1 |
    +---+---+---+

add some phrases
~~~~~~~~~~~~~~~~

now let's use those base variables and pass in some phrases! your base
variables can be anything you want but must be valid python variable
names. the phrases also have to be valid python

.. code:: python

    from truths import Truths
    print Truths(['a', 'b', 'cat', 'has_address'], ['(a and b)', 'a and b or cat', 'a and (b or cat) or has_address'])

::

    +---+---+-----+-------------+-----------+----------------+---------------------------------+
    | a | b | cat | has_address | (a and b) | a and b or cat | a and (b or cat) or has_address |
    +---+---+-----+-------------+-----------+----------------+---------------------------------+
    | 0 | 0 |  0  |      0      |     0     |       0        |                0                |
    | 0 | 0 |  0  |      1      |     0     |       0        |                1                |
    | 0 | 0 |  1  |      0      |     0     |       1        |                0                |
    | 0 | 0 |  1  |      1      |     0     |       1        |                1                |
    | 0 | 1 |  0  |      0      |     0     |       0        |                0                |
    | 0 | 1 |  0  |      1      |     0     |       0        |                1                |
    | 0 | 1 |  1  |      0      |     0     |       1        |                0                |
    | 0 | 1 |  1  |      1      |     0     |       1        |                1                |
    | 1 | 0 |  0  |      0      |     0     |       0        |                0                |
    | 1 | 0 |  0  |      1      |     0     |       0        |                1                |
    | 1 | 0 |  1  |      0      |     0     |       1        |                1                |
    | 1 | 0 |  1  |      1      |     0     |       1        |                1                |
    | 1 | 1 |  0  |      0      |     1     |       1        |                1                |
    | 1 | 1 |  0  |      1      |     1     |       1        |                1                |
    | 1 | 1 |  1  |      0      |     1     |       1        |                1                |
    | 1 | 1 |  1  |      1      |     1     |       1        |                1                |
    +---+---+-----+-------------+-----------+----------------+---------------------------------+

prefer boolean words?
~~~~~~~~~~~~~~~~~~~~~

neat eh? if you prefer True/False over the numbers pass ``ints=False``:

.. code:: python

    from truths import Truths
    print Truths(['a', 'b', 'x', 'd'], ['(a and b)', 'a and b or x', 'a and (b or x) or d'], ints=False)

::

    +-------+-------+-------+-------+-----------+--------------+---------------------+
    |   a   |   b   |   x   |   d   | (a and b) | a and b or x | a and (b or x) or d |
    +-------+-------+-------+-------+-----------+--------------+---------------------+
    | False | False | False | False |   False   |    False     |        False        |
    | False | False | False |  True |   False   |    False     |         True        |
    | False | False |  True | False |   False   |     True     |        False        |
    | False | False |  True |  True |   False   |     True     |         True        |
    | False |  True | False | False |   False   |    False     |        False        |
    | False |  True | False |  True |   False   |    False     |         True        |
    | False |  True |  True | False |   False   |     True     |        False        |
    | False |  True |  True |  True |   False   |     True     |         True        |
    |  True | False | False | False |   False   |    False     |        False        |
    |  True | False | False |  True |   False   |    False     |         True        |
    |  True | False |  True | False |   False   |     True     |         True        |
    |  True | False |  True |  True |   False   |     True     |         True        |
    |  True |  True | False | False |    True   |     True     |         True        |
    |  True |  True | False |  True |    True   |     True     |         True        |
    |  True |  True |  True | False |    True   |     True     |         True        |
    |  True |  True |  True |  True |    True   |     True     |         True        |
    +-------+-------+-------+-------+-----------+--------------+---------------------+

how it works
~~~~~~~~~~~~

check out the code! behind the scenes it's putting the bases in an
object context and generating a grid of values for them. then, the
phrases are ``eval``\ uated in the object's context against each row in
that grid of values
